#lang racket

;;; Rival correctly-rounded platform:
;;; Using #f instead of fl proc thorought the platform implies that fl will be generated by Rival with correct rounding mode

(require math/bigfloat
         math/flonum
         "../utils/float.rkt"  ; for shift/unshift
         "../syntax/platform.rkt")
(provide platform)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; EMPTY PLATFORM ;;;;;;;;;;;;;;;;;;;;;;;;

(define cost 1)

(define platform
  (make-empty-platform 'rival #:if-cost cost))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BOOLEAN ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; representation ;;;;;;;;;;;;;;;;;;;;;;;;

(define bool
  (make-representation #:name 'bool
                       #:type 'bool
                       #:repr? boolean?
                       #:bf->repr identity
                       #:repr->bf identity
                       #:ordinal->repr (λ (x) (= x 0))
                       #:repr->ordinal (λ (x) (if x 1 0))
                       #:total-bits 1
                       #:special-value? (const #f)))

(platform-register-representation! platform #:repr bool #:cost cost)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; constants ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(platform-register-implementations!
 platform
 ([TRUE  () bool (TRUE)  (const true)  (! TRUE)  cost]
  [FALSE () bool (FALSE) (const false) (! FALSE) cost]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; operators ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define (and-fn . as)
  (andmap identity as))
(define (or-fn . as)
  (ormap identity as))

(platform-register-implementations!
 platform
 ([not ([x : bool])            bool (not x)   not    (not x)   cost]
  [and ([x : bool] [y : bool]) bool (and x y) and-fn (and x y) cost]
  [or  ([x : bool] [y : bool]) bool (or x y)  or-fn  (or x y)  cost]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BINARY 32 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; representation ;;;;;;;;;;;;;;;;;;;;;;;;

(define binary32 <binary32>)

(platform-register-representation! platform #:repr binary32 #:cost cost)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BINARY 32 TABLE ;;;;;;;;;;;;;;;;;;;;;;;

; ([name         ([var : repr] ...)                             otype    spec                       fl fpcore                                          cost])
(platform-register-implementations!
 platform
 (; Constants
  [PI.f32        ()                                             binary32 (PI)                       #f (! :precision binary32 PI)              cost]
  [E.f32         ()                                             binary32 (E)                        #f (! :precision binary32 E)               cost]
  [INFINITY.f32  ()                                             binary32 (INFINITY)                 #f (! :precision binary32 INFINITY)        cost]
  [NAN.f32       ()                                             binary32 (NAN)                      #f (! :precision binary32 NAN)             cost]
  ; Default operators
  [neg.f32       ([x : binary32])                               binary32 (neg x)                    #f (! :precision binary32 (- x))           cost]
  [+.f32         ([x : binary32] [y : binary32])                binary32 (+ x y)                    #f (! :precision binary32 (+ x y))         cost]
  [-.f32         ([x : binary32] [y : binary32])                binary32 (- x y)                    #f (! :precision binary32 (- x y))         cost]
  [*.f32         ([x : binary32] [y : binary32])                binary32 (* x y)                    #f (! :precision binary32 (* x y))         cost]
  [/.f32         ([x : binary32] [y : binary32])                binary32 (/ x y)                    #f (! :precision binary32 (/ x y))         cost]
  [==.f32        ([x : binary32] [y : binary32])                bool     (== x y)                   #f (== x y)                                cost]
  [!=.f32        ([x : binary32] [y : binary32])                bool     (!= x y)                   #f (!= x y)                                cost]
  [<.f32         ([x : binary32] [y : binary32])                bool     (< x y)                    #f (< x y)                                 cost]
  [>.f32         ([x : binary32] [y : binary32])                bool     (> x y)                    #f (> x y)                                 cost]
  [<=.f32        ([x : binary32] [y : binary32])                bool     (<= x y)                   #f (<= x y)                                cost]
  [>=.f32        ([x : binary32] [y : binary32])                bool     (>= x y)                   #f (>= x y)                                cost]
  ; Unary operators
  [fabs.f32      ([x : binary32])                               binary32 (fabs x)                   #f (! :precision binary32 (fabs x))        cost]
  [sin.f32       ([x : binary32])                               binary32 (sin x)                    #f (! :precision binary32 (sin x))         cost]
  [cos.f32       ([x : binary32])                               binary32 (cos x)                    #f (! :precision binary32 (cos x))         cost]
  [tan.f32       ([x : binary32])                               binary32 (tan x)                    #f (! :precision binary32 (tan x))         cost]
  [sinh.f32      ([x : binary32])                               binary32 (sinh x)                   #f (! :precision binary32 (sinh x))        cost]
  [cosh.f32      ([x : binary32])                               binary32 (cosh x)                   #f (! :precision binary32 (cosh x))        cost]
  [acos.f32      ([x : binary32])                               binary32 (acos x)                   #f (! :precision binary32 (acos x))        cost]
  [acosh.f32     ([x : binary32])                               binary32 (acosh x)                  #f (! :precision binary32 (acosh x))       cost]
  [asin.f32      ([x : binary32])                               binary32 (asin x)                   #f (! :precision binary32 (asin x))        cost]
  [asinh.f32     ([x : binary32])                               binary32 (asinh x)                  #f (! :precision binary32 (asinh x))       cost]
  [atan.f32      ([x : binary32])                               binary32 (atan x)                   #f (! :precision binary32 (atan x))        cost]
  [atanh.f32     ([x : binary32])                               binary32 (atanh x)                  #f (! :precision binary32 (atanh x))       cost]
  [cbrt.f32      ([x : binary32])                               binary32 (cbrt x)                   #f (! :precision binary32 (cbrt x))        cost]
  [ceil.f32      ([x : binary32])                               binary32 (ceil x)                   #f (! :precision binary32 (ceil x))        cost]
  [erf.f32       ([x : binary32])                               binary32 (erf x)                    #f (! :precision binary32 (erf x))         cost]
  [exp.f32       ([x : binary32])                               binary32 (exp x)                    #f (! :precision binary32 (exp x))         cost]
  [exp2.f32      ([x : binary32])                               binary32 (exp2 x)                   #f (! :precision binary32 (exp2 x))        cost]
  [floor.f32     ([x : binary32])                               binary32 (floor x)                  #f (! :precision binary32 (floor x))       cost]
  [lgamma.f32    ([x : binary32])                               binary32 (lgamma x)                 #f (! :precision binary32 (lgamma x))      cost]
  [log.f32       ([x : binary32])                               binary32 (log x)                    #f (! :precision binary32 (log x))         cost]
  [log10.f32     ([x : binary32])                               binary32 (log10 x)                  #f (! :precision binary32 (log10 x))       cost]
  [log2.f32      ([x : binary32])                               binary32 (log2 x)                   #f (! :precision binary32 (log2 x))        cost]
  [logb.f32      ([x : binary32])                               binary32 (logb x)                   #f (! :precision binary32 (logb x))        cost]
  [rint.f32      ([x : binary32])                               binary32 (rint x)                   #f (! :precision binary32 (rint x))        cost]
  [round.f32     ([x : binary32])                               binary32 (round x)                  #f (! :precision binary32 (round x))       cost]
  [sqrt.f32      ([x : binary32])                               binary32 (sqrt x)                   #f (! :precision binary32 (sqrt x))        cost]
  [tanh.f32      ([x : binary32])                               binary32 (tanh x)                   #f (! :precision binary32 (tanh x))        cost]
  [tgamma.f32    ([x : binary32])                               binary32 (tgamma x)                 #f (! :precision binary32 (tgamma x))      cost]
  [trunc.f32     ([x : binary32])                               binary32 (trunc x)                  #f (! :precision binary32 (trunc x))       cost]
  ; Binary operators
  [pow.f32       ([x : binary32] [y : binary32])                binary32 (pow x y)                  #f (! :precision binary32 (pow x y))       cost]
  [atan2.f32     ([x : binary32] [y : binary32])                binary32 (atan2 x y)                #f (! :precision binary32 (atan2 x y))     cost]
  [copysign.f32  ([x : binary32] [y : binary32])                binary32 (copysign x y)             #f (! :precision binary32 (copysign x y))  cost]
  [fdim.f32      ([x : binary32] [y : binary32])                binary32 (fdim x y)                 #f (! :precision binary32 (fdim x y))      cost]
  [fmax.f32      ([x : binary32] [y : binary32])                binary32 (fmax x y)                 #f (! :precision binary32 (fmax x y))      cost]
  [fmin.f32      ([x : binary32] [y : binary32])                binary32 (fmin x y)                 #f (! :precision binary32 (fmin x y))      cost]
  [fmod.f32      ([x : binary32] [y : binary32])                binary32 (fmod x y)                 #f (! :precision binary32 (fmod x y))      cost]
  [remainder.f32 ([x : binary32] [y : binary32])                binary32 (remainder x y)            #f (! :precision binary32 (remainder x y)) cost]
  ; Accelerators
  [erfc.f32      ([x : binary32])                               binary32 (- 1 (erf x))              #f (! :precision binary32 (erfc x))        cost]
  [expm1.f32     ([x : binary32])                               binary32 (- (exp x) 1)              #f (! :precision binary32 (expm1 x))       cost]
  [log1p.f32     ([x : binary32])                               binary32 (log (+ 1 x))              #f (! :precision binary32 (log1p x))       cost]
  [hypot.f32     ([x : binary32] [y : binary32])                binary32 (sqrt (+ (* x x) (* y y))) #f (! :precision binary32 (hypot x y))     cost]
  [fma.f32       ([x : binary32] [y : binary32] [z : binary32]) binary32 (+ (* x y) z)              #f (! :precision binary32 (fma x y z))     cost]))
 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BINARY 64 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; representation ;;;;;;;;;;;;;;;;;;;;;;;;

(define binary64
  (make-representation #:name 'binary64
                       #:type 'real
                       #:repr? flonum?
                       #:bf->repr bigfloat->flonum
                       #:repr->bf bf
                       #:ordinal->repr (shift 63 ordinal->flonum)
                       #:repr->ordinal (unshift 63 flonum->ordinal)
                       #:total-bits 64
                       #:special-value? nan?))

(platform-register-representation! platform #:repr binary64 #:cost cost)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BINARY 64 TABLE ;;;;;;;;;;;;;;;;;;;;;;;

; ([name         ([var : repr] ...)                             otype    spec                       fl fpcore                                          cost])
(platform-register-implementations!
 platform
 (; Constants
  [PI.f64        ()                                             binary64 (PI)                       #f (! :precision binary64 PI)              cost]
  [E.f64         ()                                             binary64 (E)                        #f (! :precision binary64 E)               cost]
  [INFINITY.f64  ()                                             binary64 (INFINITY)                 #f (! :precision binary64 INFINITY)        cost]
  [NAN.f64       ()                                             binary64 (NAN)                      #f (! :precision binary64 NAN)             cost]
  ; Default operators
  [neg.f64       ([x : binary64])                               binary64 (neg x)                    #f (! :precision binary64 (- x))           cost]
  [+.f64         ([x : binary64] [y : binary64])                binary64 (+ x y)                    #f (! :precision binary64 (+ x y))         cost]
  [-.f64         ([x : binary64] [y : binary64])                binary64 (- x y)                    #f (! :precision binary64 (- x y))         cost]
  [*.f64         ([x : binary64] [y : binary64])                binary64 (* x y)                    #f (! :precision binary64 (* x y))         cost]
  [/.f64         ([x : binary64] [y : binary64])                binary64 (/ x y)                    #f (! :precision binary64 (/ x y))         cost]
  [==.f64        ([x : binary64] [y : binary64])                bool     (== x y)                   #f (== x y)                                cost]
  [!=.f64        ([x : binary64] [y : binary64])                bool     (!= x y)                   #f (!= x y)                                cost]
  [<.f64         ([x : binary64] [y : binary64])                bool     (< x y)                    #f (< x y)                                 cost]
  [>.f64         ([x : binary64] [y : binary64])                bool     (> x y)                    #f (> x y)                                 cost]
  [<=.f64        ([x : binary64] [y : binary64])                bool     (<= x y)                   #f (<= x y)                                cost]
  [>=.f64        ([x : binary64] [y : binary64])                bool     (>= x y)                   #f (>= x y)                                cost]
  ; Unary operators
  [fabs.f64      ([x : binary64])                               binary64 (fabs x)                   #f (! :precision binary64 (fabs x))        cost]
  [sin.f64       ([x : binary64])                               binary64 (sin x)                    #f (! :precision binary64 (sin x))         cost]
  [cos.f64       ([x : binary64])                               binary64 (cos x)                    #f (! :precision binary64 (cos x))         cost]
  [tan.f64       ([x : binary64])                               binary64 (tan x)                    #f (! :precision binary64 (tan x))         cost]
  [sinh.f64      ([x : binary64])                               binary64 (sinh x)                   #f (! :precision binary64 (sinh x))        cost]
  [cosh.f64      ([x : binary64])                               binary64 (cosh x)                   #f (! :precision binary64 (cosh x))        cost]
  [acos.f64      ([x : binary64])                               binary64 (acos x)                   #f (! :precision binary64 (acos x))        cost]
  [acosh.f64     ([x : binary64])                               binary64 (acosh x)                  #f (! :precision binary64 (acosh x))       cost]
  [asin.f64      ([x : binary64])                               binary64 (asin x)                   #f (! :precision binary64 (asin x))        cost]
  [asinh.f64     ([x : binary64])                               binary64 (asinh x)                  #f (! :precision binary64 (asinh x))       cost]
  [atan.f64      ([x : binary64])                               binary64 (atan x)                   #f (! :precision binary64 (atan x))        cost]
  [atanh.f64     ([x : binary64])                               binary64 (atanh x)                  #f (! :precision binary64 (atanh x))       cost]
  [cbrt.f64      ([x : binary64])                               binary64 (cbrt x)                   #f (! :precision binary64 (cbrt x))        cost]
  [ceil.f64      ([x : binary64])                               binary64 (ceil x)                   #f (! :precision binary64 (ceil x))        cost]
  [erf.f64       ([x : binary64])                               binary64 (erf x)                    #f (! :precision binary64 (erf x))         cost]
  [exp.f64       ([x : binary64])                               binary64 (exp x)                    #f (! :precision binary64 (exp x))         cost]
  [exp2.f64      ([x : binary64])                               binary64 (exp2 x)                   #f (! :precision binary64 (exp2 x))        cost]
  [floor.f64     ([x : binary64])                               binary64 (floor x)                  #f (! :precision binary64 (floor x))       cost]
  [lgamma.f64    ([x : binary64])                               binary64 (lgamma x)                 #f (! :precision binary64 (lgamma x))      cost]
  [log.f64       ([x : binary64])                               binary64 (log x)                    #f (! :precision binary64 (log x))         cost]
  [log10.f64     ([x : binary64])                               binary64 (log10 x)                  #f (! :precision binary64 (log10 x))       cost]
  [log2.f64      ([x : binary64])                               binary64 (log2 x)                   #f (! :precision binary64 (log2 x))        cost]
  [logb.f64      ([x : binary64])                               binary64 (logb x)                   #f (! :precision binary64 (logb x))        cost]
  [rint.f64      ([x : binary64])                               binary64 (rint x)                   #f (! :precision binary64 (rint x))        cost]
  [round.f64     ([x : binary64])                               binary64 (round x)                  #f (! :precision binary64 (round x))       cost]
  [sqrt.f64      ([x : binary64])                               binary64 (sqrt x)                   #f (! :precision binary64 (sqrt x))        cost]
  [tanh.f64      ([x : binary64])                               binary64 (tanh x)                   #f (! :precision binary64 (tanh x))        cost]
  [tgamma.f64    ([x : binary64])                               binary64 (tgamma x)                 #f (! :precision binary64 (tgamma x))      cost]
  [trunc.f64     ([x : binary64])                               binary64 (trunc x)                  #f (! :precision binary64 (trunc x))       cost]
  ; Binary operators
  [pow.f64       ([x : binary64] [y : binary64])                binary64 (pow x y)                  #f (! :precision binary64 (pow x y))       cost]
  [atan2.f64     ([x : binary64] [y : binary64])                binary64 (atan2 x y)                #f (! :precision binary64 (atan2 x y))     cost]
  [copysign.f64  ([x : binary64] [y : binary64])                binary64 (copysign x y)             #f (! :precision binary64 (copysign x y))  cost]
  [fdim.f64      ([x : binary64] [y : binary64])                binary64 (fdim x y)                 #f (! :precision binary64 (fdim x y))      cost]
  [fmax.f64      ([x : binary64] [y : binary64])                binary64 (fmax x y)                 #f (! :precision binary64 (fmax x y))      cost]
  [fmin.f64      ([x : binary64] [y : binary64])                binary64 (fmin x y)                 #f (! :precision binary64 (fmin x y))      cost]
  [fmod.f64      ([x : binary64] [y : binary64])                binary64 (fmod x y)                 #f (! :precision binary64 (fmod x y))      cost]
  [remainder.f64 ([x : binary64] [y : binary64])                binary64 (remainder x y)            #f (! :precision binary64 (remainder x y)) cost]
  ; Accelerators
  [erfc.f64      ([x : binary64])                               binary64 (- 1 (erf x))              #f (! :precision binary64 (erfc x))        cost]
  [expm1.f64     ([x : binary64])                               binary64 (- (exp x) 1)              #f (! :precision binary64 (expm1 x))       cost]
  [log1p.f64     ([x : binary64])                               binary64 (log (+ 1 x))              #f (! :precision binary64 (log1p x))       cost]
  [hypot.f64     ([x : binary64] [y : binary64])                binary64 (sqrt (+ (* x x) (* y y))) #f (! :precision binary64 (hypot x y))     cost]
  [fma.f64       ([x : binary64] [y : binary64] [z : binary64]) binary64 (+ (* x y) z)              #f (! :precision binary64 (fma x y z))     cost]))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; REGISTER PLATFORM ;;;;;;;;;;;;;;;;;;;;;

(module+ main
  (display-platform platform))

;; Do not run this file during testing
(module test racket/base
  )
