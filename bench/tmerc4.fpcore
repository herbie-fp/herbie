(FPCore (phi lam es k0 esp)
:name "approx-x-forward-full-series"
(let* ((cp (cos phi))
(sp (sin phi))
(t (if (> (fabs cp) 1e-10) (/ sp cp) 0.0))
(t2 (* t t))
(al (/ (* cp lam) (sqrt (- 1.0 (* es (* sp sp))))))
(als (* al al))
(n (* esp (* cp cp))))
(* k0 al
(+ 1.0
(* (/ 1.0 6.0) als
(+ (- 1.0 t2) n
(* (/ 1.0 120.0) als
(+ 5.0
(+ (* t2 (- t2 18.0))
(* n (- 14.0 (* 58.0 t2))))
(* (/ 1.0 5040.0) als
(+ 61.0 (* t2 (+ (* t2 (- 179.0)) -479.0))))))))))))

(FPCore (phi lam es k0 esp ml0 en_mlfn)
:name "approx-y-forward-full-series"
:pre (and (>= es 0.0) (<= es 1.0))
(let* ((cp (cos phi))
(sp (sin phi))
(t (if (> (fabs cp) 1e-10) (/ sp cp) 0.0))
(t2 (* t t))
(al (/ (* cp lam) (sqrt (- 1.0 (* es (* sp sp))))))
(als (* al al))
(n (* esp (* cp cp)))
;; Treat m(phi) = pj_mlfn(phi, sp, cp, en) as input en_mlfn
(mphi en_mlfn))
(* k0
(+ (- mphi ml0)
(* sp al lam 0.5
(+ 1.0
(* 0.25 als
(+ 5.0
(+ (- t2) (* n (+ 9.0 (* 4.0 n))))
(* (/ 1.0 720.0) als
(+ 61.0
(+ (* t2 (- 58.0))
(* n (+ 270.0 (* -330.0 t2)))
(* (/ 1.0 80640.0) als
(+ 1385.0
(+ (* t2 (+ (* t2 (- 543.0)) -3111.0))))))))))))))))

(FPCore (x y)
:name "auto-inv-frontier-test"
(- 0.053 (* 0.022 (* y y))))

(FPCore (phi lam)
:name "spherical-b"
(* (cos phi) (sin lam)))

(FPCore (phi lam ml0)
:name "spherical-x-log1p-like"
:pre (< (fabs (* (cos phi) (sin lam))) 1.0)
(let* ((b (* (cos phi) (sin lam))))
(* ml0 (log (/ (+ 1.0 b) (- 1.0 b))))))

(FPCore (phi lam)
:name "spherical-y-cos-over-sqrt"
:pre (< (fabs (* (cos phi) (sin lam))) 1.0)
(let* ((b (* (cos phi) (sin lam))))
(/ (* (cos phi) (cos lam))
(sqrt (- 1.0 (* b b))))))

(FPCore (phi x es k0 esp)
:name "approx-inv-delta-phi"
:pre (and (>= es 0.0) (<= es 1.0))
(let* ((cp (cos phi))
(sp (sin phi))
(t (if (> (fabs cp) 1e-10) (/ sp cp) 0.0))
(t2 (* t t))
(n (* esp (* cp cp)))
(con (- 1.0 (* es (* sp sp))))
(d (/ (* x (sqrt con)) k0))
(ds (* d d)))
(* (/ (* con ds) (- 1.0 es)) 0.5
(+ 1.0
(* (- (/ 1.0 12.0)) ds
(+ 5.0
(+ (* t2 (+ 3.0 (* -9.0 n)))
(* n (+ 1.0 (* -4.0 n))))
(* (- (/ 1.0 360.0)) ds
(+ 61.0
(+ (* t2 (+ 90.0 (* -252.0 n) (* 45.0 t2)))
(* 46.0 n)
(* (- (/ 1.0 560.0)) ds
(+ 1385.0
(+ (* t2 (+ 3633.0
(+ (* t2 (+ 4095.0
(* 1575.0 t2))))))))))))))))))

(FPCore (phi x es k0 esp)
:name "approx-inv-delta-lambda"
:pre (and (>= es 0.0) (<= es 1.0))
(let* ((cp (cos phi))
(sp (sin phi))
(t (if (> (fabs cp) 1e-10) (/ sp cp) 0.0))
(t2 (* t t))
(n (* esp (* cp cp)))
(con (- 1.0 (* es (* sp sp))))
(d (/ (* x (sqrt con)) k0))
(ds (* d d)))
(/ (* d
(+ 1.0
(* (- (/ 1.0 6.0)) ds
(+ 1.0 (* 2.0 t2) n
(* (- (/ 1.0 120.0)) ds
(+ 5.0
(+ (* t2 (+ 28.0 (* 24.0 t2) (* 8.0 n)))
(* 6.0 n)
(* (- (/ 1.0 5040.0)) ds
(+ 61.0
(+ (* t2 (+ 662.0
(+ (* t2 (+ 1320.0
(* 720.0 t2))))))))))))))))
(cos phi))))

(FPCore (Cn Ce)
:name "clenshaw-arg-RI-direct"
(let* ((sin_arg_r (sin (* 2.0 Cn)))
(cos_arg_r (cos (* 2.0 Cn)))
(sinh_arg_i (sinh (* 2.0 Ce)))
(cosh_arg_i (cosh (* 2.0 Ce))))
;; Returns a tuple in code; here we just form a hard sub-expression
(+ (* sin_arg_r cosh_arg_i) (* cos_arg_r sinh_arg_i))))

(FPCore (Cn lam)
:name "inv-denom-tanCe-optimized"
(let* ((sC (sin Cn))
(cC (cos Cn))
(cE (cos lam)))
(/ 1.0 (sqrt (+ (* sC sC) (* cC cC (* cE cE)))))))

(FPCore (Cn lam)
:name "two-inv-denom-square"
(let* ((sC (sin Cn))
(cC (cos Cn))
(cE (cos lam))
(inv (/ 1.0 (sqrt (+ (* sC sC) (* cC cC (* cE cE)))))))
(* 2.0 (* inv inv))))

(FPCore (Cn lam)
:name "sin-arg-r-optimized"
(let* ((sC (sin Cn))
(cC (cos Cn))
(cE (cos lam))
(twoinv2 (* 2.0
(/ 1.0 (+ (* sC sC) (* cC cC (* cE cE)))))))
;; twoinv2 == 2 * inv^2
(* sC cC cE twoinv2)))

(FPCore (Cn lam)
:name "cos-arg-r-optimized"
(let* ((sC (sin Cn))
(cC (cos Cn))
(cE (cos lam))
(twoinv2 (* 2.0
(/ 1.0 (+ (* sC sC) (* cC cC (* cE cE)))))))
(+ (* cC cE twoinv2) -1.0)))

(FPCore (Cn lam)
:name "tanCe-and-asinh"
(let* ((sC (sin Cn))
(cC (cos Cn))
(sE (sin lam))
(cE (cos lam))
(inv (/ 1.0 (sqrt (+ (* sC sC) (* cC cC (* cE cE))))))
(tanCe (* sE cC inv)))
(asinh tanCe)))

(FPCore (Cn lam)
:name "sinh-arg-i-optimized"
(let* ((sC (sin Cn))
(cC (cos Cn))
(sE (sin lam))
(cE (cos lam))
(inv (/ 1.0 (sqrt (+ (* sC sC) (* cC cC (* cE cE))))))
(tanCe (* sE cC inv)))
(* tanCe (* 2.0 inv))))

(FPCore (Cn lam)
:name "cosh-arg-i-optimized"
(let* ((sC (sin Cn))
(cC (cos Cn))
(cE (cos lam))
(inv (/ 1.0 (sqrt (+ (* sC sC) (* cC cC (* cE cE))))))
(twoinv2 (* 2.0 (* inv inv))))
(+ twoinv2 -1.0)))

(FPCore (Ce)
:name "sinh2C-and-cosh2C-from-exp"
(let* ((e (exp (* 2.0 Ce))))
;; sinh(2Ce) = 0.5e - 0.5/e ; cosh(2Ce) = 0.5e + 0.5/e
(- (* 0.5 e) (/ 0.5 e))))

(FPCore (Ce Cn)
:name "Ce-prime-atan2-sinhCe-cosCn"
(let* ((sinhCe (sinh Ce))
(cC (cos Cn)))
(atan2 sinhCe cC)))

(FPCore (Ce Cn)
:name "Cn-prime-atan2-sinCn-hypot"
(let* ((sinhCe (sinh Ce))
(cC (cos Cn))
(sC (sin Cn))
(modC (sqrt (+ (* sinhCe sinhCe) (* cC cC)))))
(atan2 sC modC)))

(FPCore (lam0)
:name "utm-zone-from-lon0-core"
;; This mirrors the floating arithmetic inside the zone choice,
;; minus adjlon/floor/lround; keep the hairy scale/shift.
(+ (* (/ 1.0 30.0) (+ lam0 (* (/ 1.0 30.0) 0.0))) 0.0))